# Найденные проблемы в контракте

## Проблема 1: `load_msg_addr()` возвращает кортеж
**Строка 28:** `var admin_address = ds~load_msg_addr();`

`load_msg_addr()` возвращает `(slice, slice)`, а не просто `slice`. Нужно распаковать кортеж.

**Исправление:**
```func
var (ds_rest, admin_address) = ds~load_msg_addr();
```

## Проблема 2: `sender_address()` не существует
**Строки 125, 153, 200, 261:** `slice sender = sender_address();`

Функции `sender_address()` нет в stdlib. Нужно получать адрес отправителя из `in_msg_full` в `recv_internal` и передавать в функции.

**Исправление:**
Нужно парсить `in_msg_full` для получения адреса отправителя или использовать другой способ.

## Проблема 3: `equal_slices()` не найдена
**Строки 154, 262:** `throw_unless(501, equal_slices(sender, admin_address));`

Нужно проверить, существует ли эта функция или использовать другой способ сравнения адресов.

## Проблема 4: Возвращаемое значение `load_data()`
**Строка 35:** После исправления `load_dict()` возвращается `ds_rest` вместо `ds`, но это может быть правильно, так как `ds` уже использован.

## Рекомендации

1. Исправить `load_msg_addr()` - распаковать кортеж
2. Реализовать получение адреса отправителя из `in_msg_full`
3. Проверить/реализовать сравнение адресов
4. Протестировать компиляцию после каждого исправления

